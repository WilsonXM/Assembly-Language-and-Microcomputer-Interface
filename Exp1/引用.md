# 汇编视角下C++中引用的实现

 ## 背景说明

在大二学习C++的过程中，我学习到了“引用”这种特殊的数据类型，但当时的老师对C++中的引用类型并没有给出十分严格的定义，仅仅表示**`引用相当于给了变量一个别名`**，然后给出了许多引用的用法，包括引用的定义、引用数组、指针引用（没有指向引用的指针）等，因此对于引用这种数据类型从汇编层面而言到底如何实现，我比较模糊。

同时，让我十分在意的一点是引用和指针的关系。因为学习引用时，引用是作为代替指针在函数形参的作用而被引入的，它们在很多方面都十分相似，然而它们的不同点也非常多，因此它们之间的关系一度让我感到纠缠不清，一般来说，引用和指针之间的不同点包括：

![1700031700689](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700031700689.png)

## 探索过程

### C++中基本的引用实现

首先，我们来看一个最简单的`int`型变量的引用程序：

```c++
#include <iostream>
using namespace std;
int main()
{
    int x = 1;
    int& rx = x;
    int* px = &x;
    *px++;
    rx++;
    cout << endl;
    cout << "the values:    x -> " << x << "; rx -> " << rx << endl;
    cout << "the addresses: x ->" << &x << "; rx ->" << &rx << endl;
    return 0;
}
```

运行结果如下图：

![1700054073655](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700054073655.png)

从上面我们可以发现，变量`x`和变量`x`的引用`rx`的值相同，这是显然的；**然而变量`x`和它的引用`rx`的地址也相同**。

我们知道，编译器要为程序中的变量分配内存地址，可是变量的地址却和它的引用一样，好像**编译器并没有为引用变量分配独立的内存地址**，那引用的效果是怎么实现的？

我们可以研究下面这段简单的代码：

```c++
#include <iostream>
using namespace std;
int main()
{
    int x = 1;
    int& rx = x;
    return 0;
}
```

然后查看它的汇编代码，这里选择的版本是**`x86-64 GCC 13.2`**， 同时编译命令为**`-O0`**即不优化以显示最原始的编译过程：

![1699992201094](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1699992201094.png)

阅读右边的汇编代码可以发现，`int x = 1`对应`mov DWORD PTR [rbq-12], 1`，也就是在将值1存储到相对于栈帧指针 `rbp` 偏移为-12的位置，即栈上的一个位置。这里创建了一个32位整数变量，其值为1。 下面`lea rax, [rbq-12]`将存储这个整数变量的地址放到临时的寄存器A`rax`中，下一条`int& rx = 1`对应`mov QWORD PTR [rbp-8], rax`， 将 `rax` 寄存器中的地址值存储到相对于栈帧指针 `rbp` 偏移为-8的位置。这里创建了一个64位整数变量，这是容易理解的，因为这是64位架构；

从这段汇编可以看出，编译器遇到引用类型时没有为其分配存储对应变量值的内存，而是直接将对应变量的地址存储在引用的位置上，那其实也可以看作**引用变量其实还是有相对应的内存**，只是这个内存中存储的是被引用变量的地址而已；那如果我们使用这个引用会发生什么呢？我们可以查看一下第一段引用程序的汇编，编译器配置同上；

![1700053745120](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700053745120.png)

![1700053764301](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700053764301.png)

从上边红色框中的汇编代码来看，使用引用时，编译器同样是根据地址和是否包含`&`来选择引用对应的值和地址；

当然，上面只是针对`x86-64 GCC 13.2`编译器的不优化下的结果，但是经过我的尝试，发现在其他各种编译器，例如` x86-64 clang 17.0.1 / x86 msvc v19.latest`等的不优化编译下，对直接定义在`main`函数中的可以看作静态变量的引用变量的处理方式**几乎相同**；

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700053142012.png" alt="1700053142012"  />

<img src="C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700053416526.png" alt="1700053416526"  />

此时，我们会发现，引用和指针除了有时候在寄存器的取用上有一点区别，**在底层的实现没有任何不同**，或许这就是为什么我们可以说引用是常指针

### 编译器优化后的引用实现

但是，如果我们让编译器做一些优化呢？

下面，我们让`x86-64 GCC 13.2`编译时进行`-O1`优化：

![1700055038619](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700055038619.png)

仔细检查我们可以发现，之前我们定义引用变量`rx`时，编译器会在栈帧中开辟一片空间将被引用变量的地址存放在那儿，而现在，我们定义引用变量的语句直接没有了对应的汇编代码，好像**引用变量又没有内存**了，当我们后面使用这个引用变量输出时，编译器自动地使用了被引用变量的地址作为输出函数的寻址地址；而且不止引用变量的地址不见了，连指针变量也不见了，这是什么原因呢？

查询GCC官方文档中对于编译命令的说明

![1700040162212](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700040162212.png)

以及分析上面的代码可知，编译器在这里将引用变量直接看作了被引用变量本身，这种方法或许类似所谓“常量压缩”？所有对引用变量的操作都被等价的转移到被引用变量上，此时也就不存在所谓的引用变量，所以说，引用在开了很多优化后的编译器后直接消失了......

## 探索总结

一般情况下，引用是指针的语法糖，编译器对代码中的引用和指针的实现相同，默认将所有引用变量`rx`看作 `*px`，在不开优化时编译器会在函数栈帧中记录被引用变量的地址，就和指针一样；

在编译器优化后，引用和指针都不再占用内存，而是直接以地址的形式参与运算；在机器码层面，也不存在指针，只存在地址（指针其实还隐含了类型信息）。变量这个概念也是不存在的，只有“无格式数据”，被带格式的指令操作而已。所以我们会看到引用和指针的效果一样，是因为在机器码层面，没有多余的信息去表明他们的区别了。而在语言层面，引用的确可以理解为`const`指针

## 实验体会

在开始实验之前，我一直以为引用是通过一种神奇的方式实现的，比如编译器在编译时将引用变量的符号和被引用变量的符号链接在一起，然后链接的时候直接用一个东西表示，那么汇编代码中，即使不优化也应该只有一个地址出现；

然而事实上，不优化的引用汇编实际上出现了引用变量这种东西，也真的分配了地址去存储它，就像一个指针变量一样，然后在符号表中再去记录引用的类型；

![1700059222960](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\1700059222960.png)

 从这里可以看出，编译器的作用是将语言编写的代码翻译为合理的汇编代码，只要汇编代码可以源代码的真实意图执行即可。由于机器码可以表达的概念有限（基本上就是对于寄存器和内存的运算），而高级语言可以表达的概念十分多样，所以编译器就需要将高级语言中的各种复杂概念映射（也可以看做是翻译）为机器码中的简单概念，映射的过程可能会有多种方案，其最终选择是由编译器来决定的。在C++指针和引用的翻译中，主流的C++编译器都选择将它们映射为机器码中的地址，而舍弃了其中的类型信息。 

## 经验教训

得到的经验教训就是，在没有经过实际操作和验证之前，任何猜想都是没有根据的；

就像在开始实验前我和老师交流过程中，我预设了引用和指针的实现不一样的前提，并想把这两者的不同作为重点，现在看来，这是多么无知......实际上，这两者的底层实现还真就是一样的......

## 参考文献 

[1]火善栋,杨旭东.用汇编语言解析C/C++函数调用中值传递、指针传递和引用传递的内在机制[J].计算机时代,2012(09):49-50+54.

[2]C++标准委员会关于C++标准的最新版本https://isocpp.org/

[3]`Wikipedia`上关于引用的内容